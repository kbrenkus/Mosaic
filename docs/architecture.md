# Mosaic Architecture

## Core + Retrieval Pattern

Mosaic uses a two-tier knowledge architecture:

### Static Kernel (~200 KB)

Loaded into every agent session as project knowledge. Contains:

- **Shared reasoning** (MOSAIC-REASONING.md) — Company-agnostic frameworks for people reasoning, analytical intelligence, retrieval architecture, agent coordination, and design principles.
- **Instance index** ({ORG}-INDEX.md) — Organizational topology, entity landscape, system inventory, approval authority.
- **Behavioral directives** ({ORG}-CLAUDE-BEHAVIORS.md / {ORG}-COPILOT-BEHAVIORS.md) — Agent-specific instructions for how to reason, retrieve, and respond.
- **Classification frameworks** ({ORG}-TAXONOMY-QUICK.md) — Entity types, naming conventions, classification dimensions.
- **Agent coordination** ({ORG}-A2A-QUICK.md) — Protocol summary for multi-agent collaboration.
- **Domain routing** ({ORG}-DOMAIN-ROUTER.md) — Maps queries to domain files and retrieval paths.

The kernel budget test: *Does this file teach a pattern the agent needs on every query?* If yes, it earns kernel budget. If it provides data looked up for specific queries, it belongs in retrieval.

### Dynamic Retrieval (Azure Blob via MCP)

Domain-specific reference files stored in Azure Blob Storage, accessed on demand via `get_section(file_name, section_ref)`. Contains:

- **QUICK files** — Session-level indexes (20% of data, 80% of queries). First retrieval step for any domain.
- **Full domain files** — Complete reference data for deep queries.
- **Entity-instance files** — Individual profiles (clients, projects, etc.) loaded when a specific entity is queried.

## Three-Channel Distribution

```
                    ┌─────────────────────────────┐
                    │     Source .md Files          │
                    │   (instance repo on disk)     │
                    └──────────┬──────────────────┘
                               │
                    prepare_upload.ps1
                               │
              ┌────────────────┼────────────────┐
              │                │                │
              v                v                v
    ┌─────────────┐  ┌────────────────┐  ┌──────────────┐
    │  Claude.ai   │  │   Copilot      │  │  Azure Blob  │
    │  Project     │  │   Agent        │  │  (MCP)       │
    │  Knowledge   │  │   Knowledge    │  │              │
    │  (6 .md)     │  │   (6 .txt)     │  │  All domain  │
    │              │  │                │  │  .md files   │
    │  Manual      │  │   Manual       │  │              │
    │  upload      │  │   upload       │  │  Auto-synced │
    └─────────────┘  └────────────────┘  └──────────────┘
```

- **Claude.ai** gets 6 kernel `.md` files as project knowledge (manual upload after edits)
- **Copilot** gets the same 6 kernel files as `.txt` (generated by script, manual upload)
- **Azure Blob** gets all domain/retrieval `.md` files (auto-synced by script via Azure CLI)

## MCP Server

The `get_section` tool is an Azure Function (Python) that:

1. Receives a request with `file_name` and `section_ref`
2. Reads the `.md` file from Azure Blob Storage
3. Parses markdown headers (`## N. Title` and `### N.M Title`)
4. Returns the matching section (~3-5 KB)

This enables agents to retrieve specific sections without loading entire files into context.

## Domain Architecture

Each knowledge domain follows a layered pattern:

| Layer | Content | Placement |
|-------|---------|-----------|
| **Reasoning frameworks** | How to think about this domain | Kernel (if universal) or QUICK file |
| **Routing topology** | What triggers this domain, where data lives | {ORG}-DOMAIN-ROUTER + QUICK §0 |
| **Cross-system identity** | How entities are named across systems | Domain files |
| **Entity index** | Directory of entities in this domain | QUICK file |
| **Relationship topology** | How entities relate to each other | Domain files |
| **Entity detail** | Deep profiles of individual entities | Entity-instance files |

Layers 1-3 tend toward the kernel (they shape reasoning). Layers 4-6 tend toward retrieval (they provide data). The boundaries are gradients, not walls.

## Learning Loop Architecture

Beyond answering questions, Mosaic instances *learn* through four loops that detect drift, accumulate observations, and process corrections. For the full specification, see `core/MOSAIC-OPERATIONS.md`.

```
Loop 1: Data Freshness
  Agent detects stale/wrong data -> [DELTA], [GAP], [STRUCT], [STALE]
  -> Data Corrections queue -> Pipeline batch processing

Loop 2: Reasoning Improvement
  Agent notices patterns, better methods -> [PATTERN], [RECIPE], [ONTOLOGY], [CAUSAL]
  -> Intelligence Queue -> Human review during maintenance

Loop 3: Substrate Expansion
  Agent encounters recurring query class with no domain -> [DOMAIN]
  -> Intelligence Queue -> Domain proposal (3-occurrence threshold)

Loop 4: Self-Knowledge
  Agent observes its own reasoning tendencies -> [META]
  -> Intelligence Queue -> Benchmark validation -> Behavioral tuning
```

**The key insight:** Agents already detect these signals during normal work. The innovation is mapping existing signal detection to structured output (YAML deltas) that persists across conversations and gets processed in batch during maintenance cycles.

### Pipeline Pattern

The data freshness pipeline bridges MCP-accessible live systems and deterministic file transformation:

```
Phase 1: MCP Acquisition     (Claude Code queries live systems -> JSON snapshots)
      |
Phase 2: Transformation      (Python reads snapshots + curated overlay -> regenerated sections)
      |
Phase 3.5: Enrichment Queue  (Python scans profiles for gaps -> prioritized CSV + prompts)
      |
Phase 3: Post-Processing     (Review, batch CSV, delta completion, upload)
```

The **overlay pattern** is the foundation layer: a curated YAML file containing human-judgment fields (lifecycle state, tier, strategic flags) that no system query can determine. The pipeline merges overlay data with live system data to produce reference file sections.

## Kernel Epistemology

Each kernel file serves a different epistemological function:

| Function | What It Does | Must Be Static? |
|----------|-------------|-----------------|
| **Ontological** | Defines what exists | Can often be retrieved |
| **Linguistic** | Controls naming | Must be present (shapes every reference) |
| **Procedural** | Teaches how to act | Habit-forming patterns: present. Lookup data: retrieve. |
| **Dispositional** | Shapes agent character | Must be present (defines reasoning quality) |
| **Navigational** | Maps where things live | Can often be retrieved |
| **Hermeneutical** | Teaches interpretation | Must be present (affects judgment on every query) |

The epistemological function determines whether content earns kernel budget. Dispositional and hermeneutical content must be present — it shapes reasoning character. Ontological and navigational content can often be retrieved.
